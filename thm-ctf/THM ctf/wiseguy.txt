import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()

def send_message(server, message):
    enc = message.encode()
    server.send(enc)

def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded

def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res)
    hex_encoded = setup(server, key)
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n")
    
    send_message(server,"What is the encryption key? ")
    key_answer = server.recv(4096).decode().strip()

    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()

class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
    
By analyzing the source code, we can understand that this code sets up a server that challenges users to decode an XOR-encrypted message. When a client connects, the server generates a random 5-character key and uses it to XOR each character of a hardcoded flag (THM{thisisafakeflag}). XOR encryption involves combining each character of the flag with the corresponding character of the key (cycling through the key if it's shorter than the flag) using the XOR bitwise operation. The resulting encrypted message is then converted to hexadecimal format and sent to the client. The client must then guess the random key used for encryption; if they succeed, they receive the original flag stored in a file.
Discovering Flags (CyberChef Approach)

Let us connect to the machine using netcat and the port 1337 as mentioned in the task and similar to the below picture.
Netcat Connection

CMD :-nc 10.10.220.228 1337
This XOR encoded text has flag 1: 322b0e3f3557022f2a31231b3705311257202f26270d3177240a2f3a2c1014173a7430141b0c3638
What is the encryption key?


We can see that the program generated the XOR Encoded Text in hexadecimal.

The major hint to takeaway from this is that, TryHackMe always keeps its flag in the format of “THM{…}”, and so we know the first 4 characters of the flag will be “THM{“. Hence, we can use CyberChef to first get the HexaDecimal equivalent of the plaintext “THM{“ and then try to reverse the XOR Operation we can get the starting letters of the encryption key.
THM{ in CyberChef Hex Representation

Hence, now we can try the reverse XOR Approach using the text we received. We will be taking the first 4 bytes of the text generated and use that as the key because each character in “THM{“ is taking up 1 byte (8 bits) of the message. In my case according to the message I got the key would be “6c26293e” (as these are the first 4 bytes of the XORed text).

Now, we need to find what the original “THM{“ correspond to in XOR Encoded form with the key found above. If we find that we would know the first 4 hexadecimal characters of the encrypted key. This is shown below.
THM{ in Hexadecimal after Reverse XOR Operation

As we can see “THM{“ with the key “6c26293e” corresponds to “8ndE”, these are the first 4 characters of the encrypted key. Now, we need to add the original XOR Text along with the part of the encrypted key as shown below. I need to add Hex and changed the XOR standard to UTF-8 to reflect the reverse XOR’ed output.
Reflecting the THM{ output using the XOR Encoded Text

Now, we can try a brute forcing approach on the encryption key that uses numbers, lowercase and uppercase alphabets as the source code “res = ‘’.join(random.choices(string.ascii_letters + string.digits, k=5))” mentions all numbers and lowercase & uppercase alphabets. By trial and error we get Flag 1!

Question: What is the first flag?

When I try the message with the encryption key “8ndEw” I get a meaningful message which is the flag 1!
Flag 1

Answer: THM{p1alntExtAtt4ckcAnr3alLyhUrty0urxOr}

Question: What is the second and final flag?

Let us enter the encryption key in the terminal when I entered “8ndEw”, I got flag 2!

CMD :-nc 10.10.220.228 1337
This XOR encoded text has flag 1: 322b0e3f3557022f2a31231b3705311257202f26270d3177240a2f3a2c1014173a7430141b0c3638
What is the encryption key? fcCDE
Congrats! That is the correct key! Here is flag 2: THM{BrUt3_ForC1nG_XOR_cAn_B3_FuN_nO?}

Flag 2

Answer: THM{BrUt3_ForC1nG_XOR_cAn_B3_FuN_nO?}
